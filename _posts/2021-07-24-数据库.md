## 基础概念 

函数依赖: x->f(x). F(x)函数依赖于x / x函数决定F(x) 

完全函数依赖: X -F> Y,但X任意真子集不能->Y 

部分函数依赖: X-P>Y,但Y不完全函数依赖于X(X有真子集可以->Y) 

课本例子: (Sno,Cno) -F> Grade: 完全函数依赖, (Sno,Cno)-P->Sdept, 部分函数依赖,因为Sno->Sdept 

码: K是R<U,F>(R是关系,U是属性,F是函数依赖)中的**属性/组合**,如果**K-F->R,则K是R的候选码**.(第二章:某一属性**组**的值能唯一标识一个元组,而其子集不能,则该属性组为候选码) 

**一个关系很多候选码**: 选一个作为主码(课本上主码/候选码都可能简称为码) 

**候选码的属性叫主属性**,不包含任何候选码的属性叫非主属性/非码属性. 

R中属性组X不是码,但X是另一个关系模式的码,则X是R的外码. 

(Sno,Cno)是码, Cno不是码 

 

#### 范式 

1. **第一范式（1NF）：****属性不可分**。**保持字段值是不可分解的原子值****.**比如某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。 
2. **第二范式（2NF）：符合1NF，并且，****非主属性完全依赖于码(任何一个候选码)****（也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中）**。--确保表中的每列都和主键相关. I.e. (Sno,Cno)-F->Grade, (Sno,Cno)-P->Sdept: (Sno,Cno)是码,但Sdept不完全函数依赖于它. 
3. **第三范式（3NF）：符合2NF，并且，消除传递依赖（每一列数据都和主键直接相关，而不能间接相关）**。---确保每列都和主键列直接相关,而不是间接相关.每一个**非主属性既不传递依赖于码,也不部分依赖于码****.i.e.Sno->Sdept,Sdept-/->Sno,Sdept->Sloc,Sloc传递依赖于Sno.(为了保证2NF,Sno也能直接决定Sloc,但不妨碍有传递依赖)** 
4. BCNF:符合3NF,并且,没有任何属性完全函数依赖于非码的任何一组属性. **每个决定因素都包含码****。主属性之间没有函数依赖** 

**满足BCNF: 所有非主属性对每一个码完全函数依赖. 2. 所有主属性对每个不包含它的码也是完全函数依赖.3.没有任何属性完全函数依赖于非码的任何一组属性.** 

1. 函数依赖: 关系r中不可能存在两个元组在**X上属性相等而在Y上属性值不等**.称为X确定Y或Y函数依赖于X. 
2. 完全函数依赖: X->Y,且对X任何一个真子集X'都有X'-/->Y,则称Y对X完全函数依赖.不完全函数依赖就是部分函数依赖 
3. 码: K是R<U, F>中的属性或属性组合,如果**K -F-> U ,则称K为R的候选码**.(U部分函数依赖于K则K为超码). 候选码多于一个就选一个作为主码. 包含任何一个候选码的属性叫主属性,不包含任何候选码的属性叫非主属性/非码属性. 
4. R中属性/属性组X不是R的码,但是另一个关系模式的码,称X是R的外部码,简称外码. 

 

#### 索引 

- 索引是一个单独存储在磁盘上的数据库结构，它们包含着对数据表里所有记录的引用指针，使用索引可以提高数据库特定数据的查询速度.索引时在存储引擎中实现的，因此每种存储引擎的索引不一定完全相同,并且每种存储引擎也不一定支持所有索引类型． 

索引的存储类型有两种：BTREE和HASH,具体和表的存储引擎有关．MyISAM和InnoDB存储引擎只支持BTREE;MEMORY/HEAD存储索引可以支持HASH和BTREE索引． 

**索引的优点**: 

1. 通过创建唯一索引，可以保证数据库表中每行数据的唯一性. 
2. 可以加快数据的查询速度． 
3. 在实现数据的参考完整性方面，可以加速表和表之间的连接． 
4. 再使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间 
5. 通过使用索引，可以在查询中使用优化隐藏器，提高系统的性能。 

**索引的缺点**： 

1. 创建索引和维护索引要耗费时间，并且随着数据量的增加耗费时间也增加． 
2. 索引需要占空间内存． 
3. 在对表中数据进行增加,删除和修改的时候，索引也需要动态维护，这样降低了数据维护速度． 

索引分类 

1. 普通索引和唯一索引 
2. 直接创建索引和间接创建索引 
3. 普通索引和唯一性索引 
4. 单个索引和符合索引 
5. 聚簇索引和非聚簇索引 

 

##### 索引的优点和缺点 

建立索引的优点  

1.大大加快数据的检索速度; 

2.创建唯一性索引，保证数据库表中每一行数据的唯一性; 

3.加速表和表之间的连接; 

4.在使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间。 

 #####  索引的缺点 

1.索引需要占物理空间。 
2.当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，降低了数据的维护速度。 


##### 唯一索引 

唯一索引是**不允许其中任何两行具有相同索引值**的索引。可以有多个,允许NULL 
当现有数据中存在重复的键值时，大多数数据库不允许将新创建的唯一索引与表一起保存。数据库还可能防止添加将在表中创建重复键值的新数据。例如，如果在 employee 表中职员的姓 (lname) 上创建了唯一索引，则任何两个员工都不能同姓。 

##### 主键索引 
数据库表经常有一列或列组合，其值唯一标识表中的每一行。该列称为表的主键。只有一个,不能NULL 
在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。 

##### 聚集索引 
在聚集索引中，表中行的**物理顺序与键值的逻辑（索引）顺序相同**。一个表只能包含一个聚集索引。 
如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。 

##### 联合索引: 多个列组成 

 

#### 哈希碰撞 

1. **开放地址法**(再散列法) 

开放地执法有一个公式:Hi=(H(key)+di) MOD m i=1,2,…,k(k<=m-1) 其中，m为哈希表的表长。di 是产生冲突的时候的增量序列。如果di值可能为1,2,3,…m-1，称线性探测再散列。如果di取1，则每次冲突之后，向后移动1个位置.如果di取值可能为1,-1,2,-2,4,-4,9,-9,16,-16,…kk,-kk(k<=m/2)，称二次探测再散列。如果di取值可能为伪随机数列。称伪随机探测再散列。 

1. 再哈希法Rehash 

当发生冲突时，使用第二个、第三个、哈希函数计算地址，直到无冲突时。缺点：计算时间增加。比如上面第一次按照姓首字母进行哈希，如果产生冲突可以按照姓字母首字母第二位进行哈希，再冲突，第三位，直到不冲突为止.这种方法不易产生聚集，但增加了计算时间。 

1. **链地址法**（拉链法） 

将所有关键字为同义词的记录存储在同一线性链表中.基本思想:将所有哈希地址为i的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。对比JDK 1.7 hashMap的存储结构是不是很好理解。至于1.8之后链表长度大于6rehash 为树形结构不在此处讨论。 

 

 

#### 数据库事务的四个特性及含义 
  数据库事务transanction正确执行的四个基本要素。ACID,原子性(Atomicity)、一致性(Correspondence)、隔离性(Isolation)、持久性(Durability)。 

1. 原子性:整个事务中的所有操作，**要么全部完成，要么全部不完成**，不可能停滞在中间某个环节。事务在执行过程中发**生错误，会被回滚**（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 
2. 一致性:**在事务开始之前和事务结束以后，数据库的****完整性约束没有被破坏**。 **
3. **隔离性:**相同时间同一功能只能由一个事务执行**.隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行 相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为**串行化**，为了防止事务操作间的混淆，必须串行化或序列化请 求，使得在同一时间仅有一个请求用于同一数据。 **
4. **持久性:在**事务完成以后，永久更改**.该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。 
   一般也会问事务的四个级别，理解事务并发问题的前提： 在多个事务同时使用相同的数据的时候，可能会出现并发问题。 

 

#### 完整性约束 

数据完整性(Data Integrity)是指数据的精确(Accuracy)和可靠性(Reliability)。 

分为以下四类： 

1. 实体完整性：规定表的每一行在表中是惟一的实体。 
2. 域完整性：是指表中的列必须满足某种特定的数据类型约束，其中约束又包括取值范围、精度等规定。 
3. 参照完整性：是指两个表的主关键字和外关键字的数据应一致，保证了表之间的数据的一致性，防止了数据丢失或无意义的数据在数据库中扩散。 
4. 用户定义的完整性：不同的关系数据库系统根据其应用环境的不同，往往还需要一些特殊的约束条件。用户定义的完整性即是针对某个特定关系数据库的约束条件，它反映某一具体应用必须满足的语义要求。 

与表有关的约束：包括列约束(NOT NULL（非空约束）)和表约束(PRIMARY KEY、foreign key、check、UNIQUE) 。 

 

 

#### 并发访问问题 

为了保证事务的隔离性和一致性,需要对并发操作进行正确调度 

并发操作带来的不一致性: 丢失修改,不可重复读,读脏数据 

1. 丢失修改: 

    两个事务T1,T2读入同一数据并修改,T2提交结果破坏了T1提交结果,导致T1修改丢失. i.e. T1:-1, T2:-1, T1写回, T2写回,结果只减了一次 

2. 不可重复读: 

    T1读取,T2更新.T1无法再现前一次读取结果. 

   ​	(1). **一个事务两次读取的数据内容不一致**: T1读,T2修改,再读不一样. 

   ​	(2).幻读/虚读: **一个事务两次读取的数据数据量不一样**. T1读,T2删/插 

3. 读脏数据: 

    **B事务读取到了A事务尚未提交的数据** .T1修改数据并写回磁盘,T2读同一数据,T1撤销.T2读的内容与数据库不一致 

   T1拿，T2拿 T1写 

   读已提交 读已经提交的数据 写操作拿到是未提交的状态 

   

#### 数据库的事务隔离/事务的隔离级别 

READ-UNCOMMITTED：**未提交读**，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。 
READ-COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）。 
REPEATABLE-READ：可重复读，默认级别，**保证多次读取同一个数据时，其值都和事务开始时候的内容是一致**，禁止读取到别的事务未提交的数据（会造成幻读）。 
SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。 

1、read uncommitted : 读未提交 ：哪个问题都不能解决 
2、read committed：读已提交 ：**可以解决脏读** —- oracle默认的 
3、repeatable read：可重复读：**可以解决脏读和不可重复读** —mysql默认的 
4、serializable：串行化：可以解决脏读不可重复读和虚读—相当于锁表 

Q:事务的隔离级别中没有丢失修改..那是因为隔离级别只适用同一事务? 

 

#### 数据库锁机制/数据库并发控制 

数据库锁定机制简单来说就是数据库为了保证数据的一致性而使各种共享资源在被并发访问，访问变得有序所设计的一种规则。MySQL各存储引擎使用了三种类型（级别）的锁定机制：行级锁定，页级锁定和表级锁定。 

锁粒度划分 

- **表级锁定（table-level）**：表级别的锁定是MySQL各存储引擎中最大颗粒度的锁定机制。该锁定机制最大的特点是实现逻辑非常简单，带来的系统负面影响最小。所以获取锁和释放锁的速度很快。由于表级锁一次会将整个表锁定，所以可以很好的避免困扰我们的死锁问题。当然，锁定颗粒度大所带来最大的负面影响就是出现锁定资源争用的概率也会最高，致使并大度大打折扣。表级锁分为读锁和写锁。 
- **页级锁定（page-level）**：页级锁定的特点是锁定颗粒度介于行级锁定与表级锁之间，所以获取锁定所需要的资源开销，以及所能提供的并发处理能力也同样是介于上面二者之间。另外，页级锁定和行级锁定一样，会发生死锁。 
- **行级锁定（row-level）**：行级锁定最大的特点就是锁定对象的颗粒度很小，也是目前各大数据库管理软件所实现的锁定颗粒度最小的。由于锁定颗粒度很小，所以发生锁定资源争用的概率也最小，能够给予应用程序尽可能大的并发处理能力而提高一些需要高并发应用系统的整体性能。虽然能够在并发处理能力上面有较大的优势，但是行级锁定也因此带来了不少弊端。由于锁定资源的颗粒度很小，所以每次获取锁和释放锁需要做的事情也更多，带来的消耗自然也就更大了。此外，行级锁定也最容易发生死锁。InnoDB的行级锁同样分为两种，共享锁和排他锁，同样InnoDB也引入了意向锁（表级锁）的概念，所以也就有了意向共享锁和意向排他锁，所以InnoDB实际上有四种锁，即共享锁（S）、排他锁（X）、意向共享锁（IS）、意向排他锁（IX）； 

在MySQL数据库中，使用表级锁定的主要是MyISAM，Memory，CSV等一些非事务性存储引擎，而使用行级锁定的主要是Innodb存储引擎和NDBCluster存储引擎，页级锁定主要是BerkeleyDB存储引擎的锁定方式。 

而意向锁的作用就是当一个事务在需要获取资源锁定的时候，如果遇到自己需要的资源已经被排他锁占用的时候，该事务可以需要锁定行的表上面添加一个合适的意向锁。如果自己需要一个共享锁，那么就在表上面添加一个意向共享锁。而如果自己需要的是某行（或者某些行）上面添加一个排他锁的话，则先在表上面添加一个意向排他锁。意向共享锁可以同时并存多个，但是意向排他锁同时只能有一个存在。 

|                  | **共享锁（S）** | **排他锁（X）** | **意向共享锁（IS）** | **意向排他锁（IX）** |
| ---------------- | --------------- | --------------- | -------------------- | -------------------- |
| 共享锁（S）      | 兼容            | 冲突            | 兼容                 | 冲突                 |
| 排他锁（X）      | 冲突            | 冲突            | 冲突                 | 冲突                 |
| 意向共享锁（IS） | 兼容            | 冲突            | 兼容                 | 兼容                 |
| 意向排他锁（IX） | 冲突            | 冲突            | 兼容                 | 兼容                 |

参考地址：http://www.cnblogs.com/ggjucheng/archive/2012/11/14/2770445.html 

MyISAM 表锁优化建议： 

1. 缩短锁定时间 

2. 分离能并行的操作 

3. 合理利用读写优先级 

   

#### 乐观锁，悲观锁 

- **悲观锁**:它指的是对**数据被外界**（包括本系统当前的其他事务，**以及来自外部系统的事务处理）修改持保守态度**，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制。悲观的缺陷是不论是页锁还是行锁，加锁的时间可能会很长，这样可能会长时间的限制其他用户的访问，也就是说悲观锁的并发访问性不好。 
- **乐观锁（ Optimistic Locking ）** :相对悲观锁而言，乐观锁假设**认为数据一般情况下不会造成冲突**，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则则拒绝更新并返回用户错误的信息，让用户决定如何去做。乐观锁由程序实现，不会存在死锁问题。它适用的场景也相对乐观。但乐观锁不能解决脏读的问题 

 

##### 从程序员角度的锁分类 

​	悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。 

​	乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。乐观锁不能解决脏读的问题。 

 

##### 从锁的类别上来讲，有共享锁和排他锁。 

​	**共享锁**: 又叫做**读锁**。 当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。 

​	**排他锁**: 又叫做**写锁**。 当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。 

 

##### 数据库角度锁的分类方式 

​	独占锁（Exclusive Lock）：独占锁锁定的资源只允许进行锁定操作的程序使用，其它任何对它的操作均不会被接受。执行数据更新命令，即INSERT、 UPDATE 或DELETE 命令时，SQL Server 会自动使用独占锁。但当对象上有其它锁存在时，无法对其加独占锁。独占锁一直到事务结束才能被释放。 

​	共享锁（Shared Lock）：共享锁锁定的资源可以被其它用户读取，但其它用户不能修改它。在SELECT 命令执行时，SQL Server 通常会对对象进行共享锁锁定。通常加共享锁的数据页被读取完毕后，共享锁就会立即被释放。 

​	更新锁（Update Lock）： 更新锁是为了防止死锁而设立的。当SQL Server 准备更新数据时，它首先对数据对象作更新锁锁定，这样数据将不能被修改，但可以读取。等到SQL Server 确定要进行更新数据操作时，它会自动将更新锁换为独占锁。但当对象上有其它锁存在时，无法对其作更新锁锁定。 

 

##### 关于行级锁、表级锁、页级锁 

​	可以这样理解：锁的基础理论只有乐观锁和悲观锁，从乐观锁和悲观锁理论，衍生出独占锁、共享锁、更新锁、然后行级锁、表级锁、页级锁是从锁的有效范围角度来划分。 

 

 

#### 数据库常见死锁原因及处理 

 数据库是一个多用户使用的共享资源，当多个用户并发地存取数据时，在数据库中就会产生多个事务同时存取同一数据的情况。若对并发操作不加控制就可能会读取和存储不正确的数据，破坏数据库的一致性。 

加锁是实现数据库并发控制的一个非常重要的技术。在实际应用中经常会遇到的与锁相关的异常情况，当两个事务需要一组有冲突的锁，而不能将事务继续下去的话，就会出现死锁，严重影响应用的正常执行。 
　 在数据库中有两种基本的锁类型：排它锁（Exclusive Locks，即X锁）和共享锁（Share Locks，即S锁）。当数据对象被加上排它锁时，其他的事务不能对它读取和修改。加了共享锁的数据对象可以被其他事务读取，但不能修改。数据库利用这两种基本的锁类型来对数据库的事务进行并发控制。 
　 下面总结下这两种锁造成的常见的死锁情况与解决方案: 

**一. 事务之间对资源访问顺序的交替** 

出现原因： 
一个用户A 访问表A（锁住了表A），然后又访问表B；另一个用户B 访问表B（锁住了表B），然后企图访问表A；这时用户A由于用户B已经锁住表B，它必须等待用户B释放表B才能继续，同样用户B要等用户A释放表A才能继续，这就死锁就产生了。 
解决方法： 
这种死锁比较常见，是由于程序的BUG产生的，除了调整的程序的逻辑没有其它的办法。仔细分析程序的逻辑，对于数据库的多表操作时，尽量按照相同的顺序进行处理，尽量避免同时锁定两个资源，如操作A和B两张表时，总是按先A后B的顺序处理， 必须同时锁定两个资源时，要保证在任何时刻都应该按照相同的顺序来锁定资源。 
**二. 并发修改同一记录** 

出现原因： 
　用户A查询一条纪录，然后修改该条纪录；这时用户B修改该条纪录，这时用户A的事务里锁的性质由查询的共享锁企图上升到独占锁，而用户B里的独占锁由于A有共享锁存在所以必须等A释放掉共享锁，而A由于B的独占锁而无法上升的独占锁也就不可能释放共享锁，于是出现了死锁。这种死锁由于比较隐蔽，但在稍大点的项目中经常发生。 
　一般更新模式由一个事务组成，此事务读取记录，获取资源（页或行）的共享 (S) 锁，然后修改行，此操作要求锁转换为排它 (X) 锁。如果两个事务获得了资源上的共享模式锁，然后试图同时更新数据，则一个事务尝试将锁转换为排它 (X) 锁。共享模式到排它锁的转换必须等待一段时间，因为一个事务的排它锁与其它事务的共享模式锁不兼容；发生锁等待。第二个事务试图获取排它 (X) 锁以进行更新。由于两个事务都要转换为排它 (X) 锁，并且每个事务都等待另一个事务释放共享模式锁，因此发生死锁。 
解决方法： 
a. 使用乐观锁进行控制。乐观锁大多是基于数据版本（Version）记录机制实现。即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个“version”字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。乐观锁机制避免了长事务中的数据库加锁开销（用户A和用户B操作过程中，都没有对数据库数据加锁），大大提升了大并发量下的系统整体性能表现。Hibernate 在其数据访问引擎中内置了乐观锁实现。需要注意的是，由于乐观锁机制是在我们的系统中实现，来自外部系统的用户更新操作不受我们系统的控制，因此可能会造成脏数据被更新到数据库中。 
b. 使用悲观锁进行控制。悲观锁大多数情况下依靠数据库的锁机制实现，如Oracle的Select … for update语句，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。如一个金融系统，当某个操作员读取用户的数据，并在读出的用户数据的基础上进行修改时（如更改用户账户余额），如果采用悲观锁机制，也就意味着整个操作过程中（从操作员读出数据、开始修改直至提交修改结果的全过程，甚至还包括操作员中途去煮咖啡的时间），数据库记录始终处于加锁状态，可以想见，如果面对成百上千个并发，这样的情况将导致灾难性的后果。所以，采用悲观锁进行控制时一定要考虑清楚。 
c. SqlServer可支持更新锁 
为解决死锁，SqlServer引入更新锁,它有如下特征： 
(1) 加锁的条件：当一个事务执行update语句时，数据库系统会先为事务分配一把更新锁。 
(2) 解锁的条件：当读取数据完毕，执行更新操作时，会把更新锁升级为独占锁。 
(3) 与其他锁的兼容性：更新锁与共享锁是兼容的，也就是说，一个资源可以同时放置更新锁和共享锁，但是最多放置一把更新锁。这样，当多个事务更新相同的数据时，只有一个事务能获得更新锁，然后再把更新锁升级为独占锁，其他事务必须等到前一个事务结束后，才能获取得更新锁，这就避免了死锁。 
(4) 并发性能：允许多个事务同时读锁定的资源，但不允许其他事务修改它。 
例子如下:T1: 
begin tran 
select * from table(updlock) (加更新锁) 
update table set column1='hello' 
T2: 
begin tran 
select * from table(updlock) 
update table set column1='world' 
更新锁的意思是：“我现在只想读，你们别人也可以读，但我将来可能会做更新操作，我已经获取了从共享锁（用来读）到排他锁（用来更新）的资格”。一个事物只能有一个更新锁获此资格。 
T1执行select，加更新锁。 
T2运行，准备加更新锁，但发现已经有一个更新锁在那儿了，只好等。 
当后来有user3、user4…需要查询table表中的数据时，并不会因为T1的select在执行就被阻塞，照样能查询,提高了效率。 

**三. 索引不当导致全表扫描** 

出现原因： 
如果在事务中执行了一条不满足条件的语句，执行全表扫描，把行级锁上升为表级锁，多个这样的事务执行后，就很容易产生死锁和阻塞。类似的情况还有当表中的数据量非常庞大而索引建的过少或不合适的时候，使得经常发生全表扫描，最终应用系统会越来越慢，最终发生阻塞或死锁。 
解决方法： 
SQL语句中不要使用太复杂的关联多表的查询；使用“执行计划”对SQL语句进行分析，对于有全表扫描的SQL语句，建立相应的索引进行优化。 
四.事务封锁范围大且相互等待 

 

 

锁 

视图 

DML 

CAP 

存储引擎 

  

#### SQL语言包括哪几部分？ 

每部分都有哪些操作关键字？ 

SQL语言包括数据定义(DDL)、数据操纵(DML),数据控制(DCL)和数据查询（DQL）四个部分。 

数据定义：Create Table,Alter Table,Drop Table, Craete/Drop Index等 

数据操纵：Select ,insert,update,delete, 

数据控制：grant,revoke 

数据查询：select 

 

#### MySQL外连接、内连接与自连接的区别 

先说什么是交叉连接: **交叉连接又叫笛卡尔积**，它是指不使用任何条件，直接将一个表的所有记录和另一个表中的所有记录一一匹配。 

**内连接 则是只有条件的交叉连接**，根据某个条件筛选出符合条件的记录，不符合条件的记录不会出现在结果集中，即内连接只连接匹配的行。 

**外连接 其结果集中不仅包含符合连接条件的行，而且还会包括左表、右表或两个表中的所有数据行**，这三种情况依次称之为左外连接，右外连接，和全外连接。 

左外连接 也称左连接，左表为主表，左表中的所有记录都会出现在结果集中，对于那些在右表中并没有匹配的记录，仍然要显示，右边对应的那些字段值以NULL来填充。 

右外连接 也称右连接，右表为主表，右表中的所有记录都会出现在结果集中。左连接和右连接可以互换，MySQL目前还不支持全外连接。 

UNION: 纵向合并两张表的数据,两张表的字段应该相同,UNION ALL会保留相同字段,UNION不会,JOIN相比之下偏向横向合并两张表 

 

#### CAP 

C（Consistency）是数据一致性、A（Availability）是服务可用性、P（Partition tolerance）是分区容错性。C、A、P 只能同时满足两个目标，而由于在分布式系统中，P 是必须要保留的，所以要在 C 和 A 间进行取舍。假如要保证服务的可用性，就选择 AP 模型，而要保证一致性的话，就选择 CP 模型 

 

#### NoSQL 

K-V型, 文档型, 列式检索型. 

K-V: 存储在内存,结构比较简单,不支持原子性和持久性. 

文档型: 一般是json. 可以存储复杂数据结构. 

关系型数据库: 按行存,强结构(得加锁),没内存(慢), 全文检索能力弱. 

 

#### CAS 

compare and swap 

CPU原子操作, 可以实现无锁 

**比较并交换(compare and swap, CAS)**，是原子操作的一种，可用于在多线程编程中实现不被打断的数据交换操作，从而避免多线程同时改写某一数据时由于执行顺序不确定性以及中断的不可预知性产生的数据不一致问题。 该操作通过将内存中的值与指定数据进行比较，当数值一样时将内存中的数据替换为新的值。 

 

#### ABA问题 

ABA问题是无锁结构实现中常见的一种问题，可基本表述为： 

1. 进程P1读取了一个数值A 
2. P1被挂起(时间片耗尽、中断等)，进程P2开始执行 
3. P2修改数值A为数值B，然后又修改回A 
4. P1被唤醒，比较后发现数值A没有变化，程序继续执行。 

对于P1来说，数值A未发生过改变，但实际上A已经被变化过了，继续使用可能会出现问题。在CAS操作中，由于比较的多是指针，这个问题将会变得更加严重. 

乐观锁: 加版本号进行控制. 

  