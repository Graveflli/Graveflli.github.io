### 堆&栈

malloc: 堆空间向高地址增长,映射新的虚拟内存页面到物理内存.通过系统调用brk实现. malloc也是调用brk向内核请求分配内存.

stack: 高地址保存进程环境变量和命令行参数,低地址保存函数栈帧,

没有内存分配好有问题: 

内存泄漏: malloc在堆里申请空间,在栈用指针保存它,函数结束时函数的成员变量(包括这个指针)被释放,那这块空间就找不会来了,于是无法释放这块内存. : 以下几个内存问题常见:

1. 栈溢出: 放太多数据到栈中(大型结构体和数组), 会栈溢出(stack overflow). 程序也随之终止,应当malloc申请堆空间
2. 野指针和段错误: 一个指针指向的空间已被释放,再试图通过这个指针访问已经被释放的内存会造成**段错误(Segment Fault)**.指针已经成了野指针,应当手动将野指针置空.

---

1. 栈溢出（stack smashing） 未检查输入缓冲区长度，导致数组越界，覆盖栈中局部变量空间之上的栈桢指针%ebp以及函数返回地址retaddr, 当函数返回执行ret指令时，retaddr从栈中弹出，作为下一条指令的地址赋给%eip寄存器，继而改变原程序的执行流程指向我们的 shellcode.
2. 堆溢出（malloc/free heapcorruption） 一种是和传统的栈溢出一样, 当输入超出malloc()预先分配的空间大小，就会覆盖掉这段空间之后的一段存储区域，如果该存储区域有一个重要的变量比如euid，那么我就可以用它 来攻击。另一种是典型的double-free堆腐败，在内存回收操作中，合并相邻空闲块重新插入双向链表时会有一个写4字节内存的操作，如果弱点程序由 于编程错误free()一个不存在的块，我们就可以精心伪造这个块，从而覆盖任何我们想要的值：函数的返回地址、库函数的.plt地址等

### 虚拟内存作用

1. 虚拟内存管理可以控制物理内存的访问权限, OS要求不同页面有不同访问权限,通过CPU模式和MMU的内存保护机制实现. (我: 分段超过或分页超过? 基址+偏移>段长度?)
2. 让每个进程有独立的地址空间: 不同进程的同一个VA(virtual address)被MMU映射到不同的PA,并且一个进程中不可能访问到另一个进程的数据.(肯定开始问共享库)每个进程都认为独占整个虚拟地址空间,这样链接器和加载器实现比较容易,不用考虑进程地址范围冲突.
3. VA到PA的映射给分配和释放内存带来方便: 比如malloc要分配大内存却没有连续大内存可以分配多个不连续的物理页面映射到虚拟地址范围.
4. 系统运行多个进程,为进程分配的内存可能会大于实际物理内存,但仍然能够正常运行.磁盘上用交换设备(磁盘分区/文件)临时保存虚拟内存页面,内存不够就将不常用的物理页面的数据临时保存到交换设备(换出).进程要用到被换出页面的时候再换入(从交换设备再加载回物理内存)  换入换出即换页.

### malloc

void *malloc(size_t size) : size:分配字节数,分配失败(内存耗尽)返回NULL.void\*: malloc不知道用户存什么类型数据,动态分配内存用完可以free释放掉, void free(void *ptr): 传入的参数是malloc返回的内存块首地址.  malloc之后应当判断是否成功(可能分配失败). free(p): 内存归还了但p的值没有变,应当p=null保证不出现野指针.

---

系统调用brk&sbrk: 

int brk(void *addr) : 返回堆顶部地址. void sbrk(intptr_t increment): 扩展堆:参数是增加的大小.

通过sbrk扩展堆,将这部分空间作为缓冲池,通过malloc/free管理缓冲池中的内存,避免频繁系统调用,提高性能.

### malloc实现思路

malloc使用空闲链表组织堆中空闲区块,每个空闲块有个首部:内存控制块(mem_control_block),记录指向下一个分配块的指针和这个块的长度,还有是否已经被分配出去.(这个首部(控制块))对程序不可见,因为malloc返回控制块后面地址(可用空间起始地址).

malloc分配时: 搜索空闲链表,找到一个大于等于需要空间的空闲块,然后分配并返回指针,如果没有这样的块就会向OS申请扩展堆内存.  free:会将区块重新插入空闲链表中.因为首部保存了块的大小所以free只接受指针就可以释放恰当大小的内存.

malloc具体实现可以首次适应,最佳适应这种,可以一个链表管理所有已分配和未分配的内存块.

### mmap

mmap作用,在应用层面上是把文件的某一段当作内存一样访问.**将文件映射到物理内存,将进程的虚拟空间映射到那块内存**. 这样,**进程不仅能像访问内存一样读写文件,多个进程映射同一文件,还能保证虚拟空间映射到同一块物理内存,达到共享的作用**.

页式: 虚拟地址(页号P, 页内偏移W) 通过页表基址寄存器和页号相加的值(key)查页表,查询页表(key,value)得到value(物理页号P_). 通过拼接物理页号和页内偏移得到地址访问主存地址, 取得地址中的数据.

段式: 虚拟地址(段号S, 段内偏移W), 通过段号查段表(段号,长度L,基址B)得到基址,通过基址和偏移量得到实地址.

段页: 段表(段号, 页表长度, 页表始址). 0段页表(页号,其他,块号)

mmap映射: **就是将文件映射到内存上，进程直接对内存进行读写，然后就会反映到磁盘上**.(这里不强掉虚拟空间,(透明化)) 

具体映射过程: 1. 进程虚拟空间获得一段连续地址, 没有读写的时候地址指向不存在的地方,进程要读写文件数据时根据偏移量找到要读写的页,通过缺页中断OS给这几个页分配内存,刚分配的页是空的,通过相同偏移量将文件数据拷贝到物理内存对应的页上.

### linux内存分配管理

32位X86: 每个进程虚拟地址空间:0-4GB, 其中0-3GB是用户态,3-3+896M是内核态,剩下的128M是vmalloc保留区,用于kmalloc,kmap固定地址映射,让内核访问高端物理地址空间.

进程地址空间由mm_struct描述, 一个进程只有一个mm_struct.系统内核态共享,不会缺页终端/访问用户进程空间,所以内核线程的task_struct->mm为NULL.

页表分配: 

- 内核页表: 系统启动中在paging_init函数中把物理页面和内核态地址(3-3+896M)直接映射.
- 内核高端地址和用户态地址是通过MMU机制修改线性地址/虚拟地址和物理地址的映射关系,然后刷新页表缓存达到.

#### 伙伴系统

物理内存频繁申请和释放会产生外部碎片,通过伙伴系统解决.

具有相同大小,物理地址连续的两个块叫伙伴.伙伴系统在申请内存的时候让最小的块满足申请的需求，在归还的时候，尽量让连续的小块内存伙伴合并成大块，降低外部碎片出现的可能性。

linux伙伴系统维护11个块链表,每个块链表包含2^0 - 2^11个连续物理页. 每个块第一个页框的物理地址就是该块大小的整数倍.(大小)

#### slab分配器

解决内部碎片. 一种内存预分配机制.用空间换时间.

设计思想: 将若干个页框合在一起形成一个存储块slab,在这里面只存同一类数据,就可以打破页界限,尽可能减少页碎片.  slab_full:完全分配出去. slabs_free:链表都是空闲状态, labs_partical:部分分配.

对内核态内存分配主要是kmalloc, vmalloc. 

### 共享内存

进程间数据共享,比其他通信方式更快,(少了两次用户态和内核态之间的数据拷贝).进程不通过执行进入内核的系统调用来传递数据,而是直接进行读写.

不存在同步与互斥? 共享内存不保证同步,用信号量来保证共享内存同步

实现原理: 

1. 物理内存开辟一块空间
2. 将这块空间通过页表映射到进程虚拟地址空间
3. 通过虚拟地址进行内存操作
4. 接触映射关系 删除共享内存.

linux实现共享内存:

IPC通信中的System V, 存储映射IO(mmap函数), POSIX(基于mmap)

